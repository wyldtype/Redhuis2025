sapply(c("tidyr", "dplyr", "readr", "purrr", "ggplot2", "ggbeeswarm"), require, character.only=TRUE)
library(MASS, include.only = "glm.nb")
setwd("/Users/annar/Documents/Wittkopp_Lab/networks/DDivergence/Redhuis2025/")
source("functions_for_figure_scripts.R")
load("data_files/GLM_Counts.RData")
ExperimentNames <- c("CC", "HAP4", "LowN", "LowPi", "Heat", "Cold")

#### Single Gene Model Fitting ####
# fits one model to detect significant allele effect on one gene from one environment-specific dataset
# @input: single gene df (counts and all columns of sample info) and name of gene in one experiment
# @output: model generated by glm.nb (or NA if any error or warning is thrown)
fitSingleGeneModel <- function(.df, .gene_name) {
  # Note: we're not modeling the random effect of well_flask_ID (+ (allele|well_flask_ID)) b/c the glmer.nb function took way longer to run and didn't seem to make a difference for the few genes I tried it on, but just wanted to doccument that somewhere
  if (length(unique(.df$genotype)) > 2) { # LowN with TFdels
    form <- formula(expr ~ genotype + time_point_str + allele + genotype:time_point_str + genotype:allele)
  }
  if (length(unique(.df$genotype)) == 2) { # HAP4 with HAP4del and WT
    form <- formula(expr ~ genotype + time_point_num + allele)
  }
  if (length(unique(.df$genotype)) == 1) { # CC, LowPi, Heat, Cold, LowN WT, and HAP4 WT
    form <- formula(expr ~ time_point_num + allele)
  }
  output <- tryCatch({glm.nb(form, .df, link = log, init.theta = 7)
  }, error = function(e) {
    return(NA)
  })
  return(output)
}

# Tests for fitSingleGeneModel
# re-run this block to your heart's desire
random_gene <- sample(rownames(spcts[[1]]), 1) # YOR222W is a good example of a gene with one outlier measurement that shouldn't be called as diverged
random_dataset_idx <- sample(c(1:length(ExperimentNames)), 1)
random_cts <- spcts[[random_dataset_idx]]
random_info <- spinfo[[random_dataset_idx]]
test_genedf <- bind_cols(tibble(expr = random_cts[random_gene,],
                                gene_name = random_gene,
                                allele_or_species = "species"),
                         random_info)
spmod <- fitSingleGeneModel(test_genedf, random_gene)
summary(spmod)
# note that the default residuals from glm.nb are working residuals, less intuitive than response residuals (actual - fitted value)
spmod$residuals[1]
resid(spmod, type = "working")[1]
resid(spmod, type = "response")[1]
test_genedf$expr[1] - spmod$fitted.values[1]
# given dataframe of all gene's counts, plots Scer expression vs Spar expression 
# for average of replicates at each timepoint (or moving average for LowPi and HAP4)
plotSingleGeneModelExample <- function(.genedf, .gene_name, .fitted_vals = FALSE, .log2 = TRUE,
                                       .size = 3) {
  .mod <- fitSingleGeneModel(.genedf, random_gene)
  sprow <- summary(.mod)$coefficients["allelecer",, drop = FALSE]
  fold_change <- exp(sprow[1])
  # plotting (averaging each timepoint down to a single expr value per species)
  # if no replicates to average, taking a sliding window of 5
  genedf_collapsed <- group_by(.genedf, time_point_num, allele) |> 
    summarise(expr = mean(expr)) |> ungroup()
  if (unique(.genedf$experiment) %in% c("LowPi", "HAP4")) {
    cat("no replicates for this experiment, getting moving average\n")
    genedf_cer <- genedf_collapsed |> filter(allele == "cer") |> 
      arrange(time_point_num)
    genedf_par <- genedf_collapsed |> filter(allele == "par") |> 
      arrange(time_point_num)
    cts_cer <- matrix(as.numeric(genedf_cer$expr), 
                      nrow = 1, ncol = nrow(genedf_cer))
    colnames(cts_cer) <- as.character(genedf_cer$time_point_num)
    cts_par <- matrix(as.numeric(genedf_par$expr), 
                      nrow = 1, ncol = nrow(genedf_par))
    colnames(cts_par) <- as.character(genedf_par$time_point_num)
    movavg_cer <- getMovingAverage(cts_cer)
    movavg_par <- getMovingAverage(cts_par)
    movavg <- bind_rows(tibble(expr = as.numeric(movavg_cer),
                               allele = "cer",
                               time_point_num = as.numeric(colnames(movavg_cer))),
                        tibble(expr = as.numeric(movavg_par),
                               allele = "par",
                               time_point_num = as.numeric(colnames(movavg_par))))
    genedf_collapsed <- movavg
  }
  plotdf <- .genedf %>% mutate(fittedvals = .mod$fitted.values) %>% 
    select(allele, time_point_num, fittedvals) %>% 
    unique() |> 
    left_join(y = genedf_collapsed, by = c("time_point_num", "allele")) |> 
    pivot_longer(cols = c(expr, fittedvals)) %>% 
    pivot_wider(id_cols = c(time_point_num, name), 
                names_from = allele, values_from = value)
  if (!.log2) {
    slope <- 1/fold_change # inverse b/c Scer is conventionally put on the x axis but also conventionally has positive lfc
    norm_func <- identity
    units_text <- "(cpm)"
  }
  if (.log2) { # technically the model is a subtly curved line now,
    # dx/dy = log(x, base = y),
    # but as the fitted values tend to be bunched in one place,
    # we can summarise them as a line
    slope <- map2(plotdf$cer[plotdf$name == "fittedvals"], 
                  plotdf$par[plotdf$name == "fittedvals"], \(x, y) {
      return(log(y, base = x))
    }) |> unlist() |> mean()
    norm_func <- log2
    units_text <- "(log2(cpm))"
  }
  max_expr <-  filter(plotdf, name != "fittedvals") |> select(cer, par) |> 
    unlist() |> as.numeric() |> max(na.rm = TRUE) |> norm_func()
  min_expr <-  filter(plotdf, name != "fittedvals") |> select(cer, par) |> 
    unlist() |> as.numeric() |> min(na.rm = TRUE) |> norm_func()
  cat("min and max expression:", max_expr, min_expr, "\n")
  if (.fitted_vals) {
    p <- ggplot(plotdf, aes(x = norm_func(cer), y = norm_func(par))) + 
      geom_point(aes(color = name), size = .size) +
      geom_abline(color = "gold", slope = slope, intercept = 0) + 
      geom_abline(color = "navy", slope = 1, intercept = 0) + 
      ggtitle(paste("slope = ", round(slope, 2), 
                    "\nl2fc = ", round(log2(fold_change), 2),
                    "\npval = ", round(sprow[4] + 5*10^(-5), 4))) + # this is essentially ceiling(sprow[4], digits = 4) except ceiling doesn't allow decimals
      xlim(c(min_expr, max_expr)) + 
      ylim(c(min_expr, max_expr)) + 
      xlab(paste("Scer expression", units_text)) +
      ylab(paste("Spar expression", units_text)) +
      theme_classic()
  }
  if (!.fitted_vals) {
    # filtering down to 11 tps for scale_color_brewer (ever other one then last 8)
    ntps <- length(unique(plotdf$time_point_num))
    if (ntps > 11) {
      good_tps <- unique(plotdf$time_point_num)[order(unique(plotdf$time_point_num))][c(1, 3, 5, (ntps-7):ntps)]
      plotdf <- filter(plotdf, time_point_num %in% good_tps)
    }
    plotdf$time_point_num <- as.factor(plotdf$time_point_num)
    p <- ggplot(filter(plotdf, name != "fittedvals"), aes(x = norm_func(cer), y = norm_func(par))) + 
      geom_point(aes(color = time_point_num), size = .size) +
      scale_color_brewer(type = "div",
                         palette = "RdYlGn",
                         direction = 1) +
      geom_abline(color = "gold", slope = slope, intercept = 0) + 
      geom_abline(color = "navy", slope = 1, intercept = 0) + 
      ggtitle(paste("slope = ", round(slope, 2), 
                    "\nl2fc = ", round(log2(fold_change), 2),
                    "\npval = ", round(sprow[4] + 5*10^(-5), 4))) + # this is essentially ceiling(sprow[4], digits = 4) except ceiling doesn't allow decimals
      xlim(c(min_expr, max_expr)) + 
      ylim(c(min_expr, max_expr)) + 
      xlab(paste("Scer expression", units_text)) +
      ylab(paste("Spar expression", units_text)) +
      theme_classic()
  }
  return(p)
}
plotSingleGeneModelExample(test_genedf, random_gene, 
                           .log2 = TRUE, .fitted_vals = TRUE)
plotSingleGeneModelExample(test_genedf, random_gene, 
                           .log2 = FALSE, .fitted_vals = FALSE)

#### Plots for LFC calculation figure panel ####
# plot of example gene diverging in level
gene_idx <- "YBR067C" # decided in Saturated Growth script
test_genedf <- bind_cols(tibble(expr = spcts$HAP4[gene_idx,],
                                gene_name = gene_idx,
                                allele_or_species = "species"),
                         spinfo$HAP4)
pdf("../../aligning_the_molecular_phenotype/paper_figures/ExperimentOverview/level_lfc.pdf",
    width = 2.1, height = 2.5)
plotSingleGeneModelExample(test_genedf, gene_idx, .log2 = FALSE) +
  theme(legend.position = "none")
dev.off()

# plot of example gene diverging in dynamics, showing high noise but going in different directions at different timepoints
gene_idx <- "YJR001W" # decided in Saturated Growth script
test_genedf <- bind_cols(tibble(expr = spcts$HAP4[gene_idx,],
                                gene_name = gene_idx,
                                allele_or_species = "species"),
                         spinfo$HAP4)
pdf("../../aligning_the_molecular_phenotype/paper_figures/ExperimentOverview/dynamics_lfc.pdf",
    width = 2.1, height = 2.5)
plotSingleGeneModelExample(test_genedf, gene_idx, .log2 = FALSE) +
  theme(legend.position = "none")
dev.off()

#### Full model fitting ####
# fit models to all genes in one experiment's dataset
fitDatasetModels <- function(.cts, .info) {
  output <- map(rownames(.cts), function(g) {
    cat(which(rownames(.cts) == g), "/", nrow(.cts), "\n")
    cat("currently processing", g, "\n")
    gdf <- bind_cols(tibble(expr = .cts[g,]),
                     .info)
    mod <- fitSingleGeneModel(gdf, g)
    return(mod)
  })
  return(output)
}
# test for fitDatasetModels (don't need to let it run all the way)
random_dataset_idx <- sample(c(1:length(ExperimentNames)), 1)
test <- fitDatasetModels(spcts[[random_dataset_idx]][1:10,], spinfo[[random_dataset_idx]])

# applying to each experiment (takes ~1-2 min per dataset)
spmods <- map2(spcts, spinfo, fitDatasetModels)
spmods <- map2(spmods, spcts, function(x, y) {
  names(x) <- rownames(y)
  return(x)
})

# convert one model into one row of a dataframe summarizing that model's output (gene name, name of coefficient, effect size of coefficient, pvalue for wald test of that coefficient)
# also changes lfc to l2fc using change of base: log2(fc) = log(fc)/log(2)
parseDfRowFromModel <- function(.mod, .gene_name) {
  cat("currently processing", .gene_name, "\n")
  allelerow <- summary(.mod)$coefficients["allelecer",, drop = FALSE]
  result <- tibble(gene_name = .gene_name,
                   coefficient = gsub("allele", "", rownames(allelerow)), # should always have the non-reference level (cer if par is set to reference), but this just helps us be more sure
                   effect_size = as.numeric(allelerow[,"Estimate"])/log(2),
                   pvalue = as.numeric(allelerow[,"Pr(>|z|)"]))
  return(result)
}
# test for parseDfRowFromModel
random_dataset_idx <- sample(c(1:length(ExperimentNames)), 1)
random_modslist <- spmods[[random_dataset_idx]]
gene_idx <- names(random_modslist)[sample(which(!is.na(random_modslist)), 1)]
parseDfRowFromModel(random_modslist[[gene_idx]], gene_idx)

parseDfFromModslist <- function(.modslist) {
  good_idxs <- which(!is.na(.modslist))
  result <- map2(.modslist[good_idxs], names(.modslist)[good_idxs], function(mod, gname) {
    return(parseDfRowFromModel(mod, gname))
  }) %>% Reduce(f = bind_rows)
  return(result)
}
# test for parseDfRowFromModel
random_dataset_idx <- sample(c(1:length(ExperimentNames)), 1)
test <- parseDfFromModslist(spmods[[random_dataset_idx]][c(1:10)])
test

# applying parseDfFromModslist to spmods
spdfs <- lapply(spmods, parseDfFromModslist)

# adding experiment name column so the 4 datasets can be combined
spdfs <- map2(spdfs, names(spdfs), function(x, y) {
  x$experiment <- y
  return(x)
})
spdf <- Reduce(f = bind_rows, spdfs)

# renaming coefficient so that the species models can be added to allele models in aldf below
spdf$coefficient <- "species"

# applying to each experiment (takes ~1-2 min per dataset)
almods <- map2(alcts, alinfo, fitDatasetModels)
almods <- map2(almods, alcts, function(x, y) {
  names(x) <- rownames(y)
  return(x)
})

# applying parseDfFromModslist and parseAvgCompsFromModslist to spmods
aldfs <- lapply(almods, parseDfFromModslist)

# cleaning some column values so aldfs and alavgs can be combined into one df
# adding experiment name column
aldfs <- map2(aldfs, names(aldfs), function(x, y) {
  x$experiment <- y
  return(x)
})

aldf <- Reduce(f = bind_rows, aldfs)
# renaming coefficient
aldf$coefficient <- "allele"

spaldf <- full_join(aldf, spdf, by = c("gene_name", "experiment", "coefficient", "effect_size", "pvalue"))

# different nGenes in each experiment b/c different genes were filtered out by low expression in the data script
spaldf %>% filter(coefficient == "species") %>% select(experiment) %>% table()
spaldf %>% filter(coefficient == "allele") %>% select(experiment) %>% table()

#################### Dataframe cleaning and QC ##############################
library(ggpubr)
# Valuable functions for examining individual genes
getExprVector <- function(.gene_name, .organism = "cer", 
                          .experiment = c("LowN", "CC", "HAP4", "LowPi")) {
  if (.organism %in% c("cer", "par")) {
    common_idxs <- Reduce(map(spcts[.experiment], rownames), f = intersect)
    stopifnot("gene is not common to all experiments requested\n" = .gene_name %in% common_idxs)
    info <- spinfo[.experiment] %>% Reduce(f = bind_rows) # allows for multiple experiments
    cts <- map(spcts[.experiment], \(x) x[common_idxs,]) %>% Reduce(f = cbind)
    expr <- cts[.gene_name, info$organism == .organism]
  }
  if (.organism == "hyb") {
    common_idxs <- Reduce(map(alcts[.experiment], rownames), f = intersect)
    stopifnot("gene is not common to all experiments requested\n" = .gene_name %in% common_idxs)
    info <- alinfo[.experiment] %>% Reduce(f = bind_rows)
    cts <- map(alcts[.experiment], \(x) x[common_idxs,]) %>% Reduce(f = cbind)
    expr_hyc <- cts[.gene_name, info$organism == .organism & info$allele == "cer"]
    expr_hyp <- cts[.gene_name, info$organism == .organism & info$allele == "par"]
    expr <- expr_hyc + expr_hyp
  }
  if (.organism == "hyc") {
    common_idxs <- Reduce(map(alcts[.experiment], rownames), f = intersect)
    stopifnot("gene is not common to all experiments requested\n" = .gene_name %in% common_idxs)
    info <- alinfo[.experiment] %>% Reduce(f = bind_rows)
    cts <- map(alcts[.experiment], \(x) x[common_idxs,]) %>% Reduce(f = cbind)
    expr <- cts[.gene_name, info$organism == "hyb" & info$allele == "cer"]
  }
  if (.organism == "hyp") {
    common_idxs <- Reduce(map(alcts[.experiment], rownames), f = intersect)
    stopifnot("gene is not common to all experiments requested\n" = .gene_name %in% common_idxs)
    info <- alinfo[.experiment] %>% Reduce(f = bind_rows)
    cts <- map(alcts[.experiment], \(x) x[common_idxs,]) %>% Reduce(f = cbind)
    expr <- cts[.gene_name, info$organism == "hyb" & info$allele == "par"]
  }
  return(expr)
}
# tests for getExprVector (use .experiment = ExperimentNames to get counts from all 4 experiments)
# should hit error (TDH3 isn't in Heat/Cold):
# cer_expr <- getExprVector(.gene_name = "YGR192C", .organism = "cer", .experiment = ExperimentNames)
# should work:
cer_expr <- getExprVector(.gene_name = "YGR192C", .organism = "cer", .experiment = c("CC", "HAP4", "LowN", "LowPi"))
par_expr <- getExprVector(.gene_name = "YGR192C", .organism = "par", .experiment = c("CC", "HAP4", "LowN", "LowPi"))
hyc_expr <- getExprVector(.gene_name = "YGR192C", .organism = "hyc", .experiment = c("CC", "HAP4", "LowN", "LowPi"))
hyp_expr <- getExprVector(.gene_name = "YGR192C", .organism = "hyp", .experiment = c("CC", "HAP4", "LowN", "LowPi"))
tibble(organism = c("cer", "par", "hyc", "hyp"),
       variance = map_dbl(list(cer_expr, par_expr, hyc_expr, hyp_expr), var, na.rm = TRUE),
       mean = map_dbl(list(cer_expr, par_expr, hyc_expr, hyp_expr), mean, na.rm = TRUE),
       median = map_dbl(list(cer_expr, par_expr, hyc_expr, hyp_expr), median, na.rm = TRUE))

getGeneDf <- function(.gene_name, .mode = c("parents", "hybrid"), 
                      .experiment = c("LowN", "CC", "HAP4", "LowPi")) {
  if (.mode == "parents") {
    info_cer <- spinfo[.experiment] %>% Reduce(f = bind_rows) |> filter(allele == "cer")
    info_par <- spinfo[.experiment] %>% Reduce(f = bind_rows) |> filter(allele == "par")
    cts_cer <- getExprVector(.gene_name, .experiment = .experiment, .organism = "cer")
    cts_par <- getExprVector(.gene_name, .experiment = .experiment, .organism = "par")
  }
  if (.mode == "hybrid") {
    info_cer <- alinfo[.experiment] %>% Reduce(f = bind_rows) |> filter(allele == "cer")
    info_par <- alinfo[.experiment] %>% Reduce(f = bind_rows) |> filter(allele == "par")
    cts_cer <- getExprVector(.gene_name, .experiment = .experiment, .organism = "hyc")
    cts_par <- getExprVector(.gene_name, .experiment = .experiment, .organism = "hyp")
  }
  genedf <- bind_rows(bind_cols(tibble(expr = cts_cer), 
                                select(info_cer, experiment, time_point_num, allele)), 
                      bind_cols(tibble(expr = cts_par), 
                                select(info_par, experiment, time_point_num, allele))) |> 
    summarise(expr = mean(expr), .by = c("experiment", "time_point_num", "allele")) |> 
    pivot_wider(id_cols = c("experiment", "time_point_num"),
                names_from = allele, values_from = expr)
  return(drop_na(genedf))
}
# tests for getGeneDf
gene_idx <- sample(rownames(spcts[[1]]), 1)
test <- getGeneDf(gene_idx, .mode = "parents", .experiment = c("CC", "HAP4", "LowN", "LowPi"))
ggplot(test, aes(x = cer, y = par)) + geom_point(aes(color = experiment)) + ggtitle(gene_idx) + geom_abline(color = "gold")
test <- getGeneDf(gene_idx, .mode = "hybrid", .experiment = c("CC", "HAP4", "LowN", "LowPi")) # hybrid should be less variable because cer and par measurements were collected in the same cell
ggplot(test, aes(x = cer, y = par)) + geom_point(aes(color = experiment)) + ggtitle(gene_idx) + geom_abline(color = "gold")
spaldf %>% filter(gene_name == gene_idx)

# Visualizing expression variability and divergence in...
# A) boxplots (divergence readily apparent, variability hardly apparent) 
# B) scatterplots (variability more apparent, divergence also apparent, so might just stick to scatterplots alone)
visualizeGeneExpressionBoxplot <- function(.name, .experiment = c("CC", "HAP4", "LowN", "LowPi")) {
  aldf <- getGeneDf(.name, "hybrid", .experiment = .experiment)
  spdf <- getGeneDf(.name, "parents", .experiment = .experiment)
  aldf$allele_or_species <- "allele"
  spdf$allele_or_species <- "species"
  plotdf <- bind_rows(aldf, spdf) %>% pivot_longer(cols = c("cer", "par"), names_to = "allele", values_to = "expr")
  output <- ggplot(plotdf, aes(x = paste(allele_or_species, allele), y = log(expr))) + 
    geom_boxplot(aes(fill = paste(allele_or_species, allele))) + 
    ggtitle(.name) + xlab(element_blank()) + ylab("log(expression level)") + 
    scale_x_discrete(limits = c("species cer", "species par", "allele cer", "allele par")) + # this switches the order
    theme_classic() + scale_fill_manual(breaks = c("species cer", "species par", "allele cer", "allele par"), # this sets the colors to match (yes you need breaks even though you've just specified the order above)
                                        values = c("gold", "mediumorchid", "lemonchiffon", "plum")) +
    theme(legend.position = "none")
  return(output)
}
visualizeGeneExpressionBoxplot("YGR192C")

visualizeGeneExpressionScatterplot <- function(.gdf, .plotname = "individual gene counts", .color_from = "experiment", .log = FALSE) {
  if (!.log) {
    max_expr <- max(c(.gdf$cer, .gdf$par), na.rm = TRUE)
    output <- ggplot(.gdf, aes(x = cer, y = par)) + 
      geom_point(aes(color = pull(.gdf[, as.character(.color_from)]))) + geom_abline(color = "gold") +
      ggtitle(.plotname) + xlab("expression level in cerevisiae") + ylab("expression level in paradoxus") + 
      theme_classic() + xlim(c(0, max_expr)) + ylim(c(0, max_expr)) + theme(legend.title = element_blank())
    return(output)
  }
  if (.log) {
    max_expr <- max(c(log(.gdf$cer), log(.gdf$par)), na.rm = TRUE)
    output <- ggplot(.gdf, aes(x = log(cer), y = log(par))) + 
      geom_point(aes(color = pull(.gdf[, as.character(.color_from)]))) + geom_abline(color = "gold") +
      ggtitle(.plotname) + xlab("expression level in cerevisiae") + ylab("expression level in paradoxus") + 
      theme_classic() + xlim(c(0, max_expr)) + ylim(c(0, max_expr)) + theme(legend.title = element_blank())
    return(output)
  }
}
# TDH3
getGeneDf("YGR192C", .mode = "parents") %>% visualizeGeneExpressionScatterplot(.plotname = "YGR192C - parents")
getGeneDf("YGR192C", .mode = "hybrid") %>% visualizeGeneExpressionScatterplot(.plotname = "YGR192C - hybrid")
getGeneDf("YGR192C", .mode = "parents") %>% visualizeGeneExpressionScatterplot(.plotname = "YGR192C - parents - log scale", .log = TRUE)

# random gene
gene_idx <- sample(rownames(spcts[[1]]), 1)
getGeneDf(gene_idx, .mode = "parents") %>% visualizeGeneExpressionScatterplot(.plotname = paste(gene_idx, "parents", sep = " - "))
getGeneDf(gene_idx, .mode = "hybrid") %>% visualizeGeneExpressionScatterplot(.plotname = paste(gene_idx, "hybrid", sep = " - "))
# random gene, common to all experiments
gene_idx <- map(spcts, rownames) |> reduce(.f = intersect) |> sample(1)
getGeneDf(gene_idx, .mode = "parents", .experiment = ExperimentNames) %>% 
  visualizeGeneExpressionScatterplot(.plotname = paste(gene_idx, "parents", sep = " - "))
getGeneDf(gene_idx, .mode = "hybrid", .experiment = ExperimentNames) %>% 
  visualizeGeneExpressionScatterplot(.plotname = paste(gene_idx, "hybrid", sep = " - "))

# random gene with high effect_size (in parent and/or hybrid)
gene_idx <- sample(spaldf$gene_name[spaldf$effect_size > 1 & spaldf$pvalue < 10e-8], 1)
getGeneDf(gene_idx, .mode = "parents") %>% visualizeGeneExpressionScatterplot(.plotname = paste(gene_idx, "parents", sep = " - "))
getGeneDf(gene_idx, .mode = "hybrid") %>% visualizeGeneExpressionScatterplot(.plotname = paste(gene_idx, "hybrid", sep = " - "))
spaldf %>% filter(gene_name == gene_idx)

# QC: picking threshold for calling sig diverged between cer and par
# Goal: We know there's no true biological threshold for when a gene is or is not diverged,
# but we want to draw a threshold beyond which we are fairly certain that the gene is truly diverged
# and use genes beyond that threshold as a SAMPLE of diverged genes to ask if there's anything unique about them
p_thresh <- 0.05/(nrow(spcts[[1]])*6) # correcting for multiple tests: 6 experiments + the full model
# eff_thresh <- 1 

# Volcano plot
library(ggExtra)
ggMarginal(ggplot(spaldf, aes(x = effect_size, y = -log(pvalue))) + 
  geom_point(aes(color = pvalue < p_thresh)) +
  theme(legend.position = "none") + geom_vline(xintercept = c(-1, 1), color = "gold"),
  margins = "both", groupColour = TRUE, groupFill = TRUE)

# creating genedf, where each row is one gene
genedf <-  spaldf %>%
  pivot_wider(names_from = c("experiment", "coefficient"), values_from = c("effect_size", "pvalue"), id_cols = c("gene_name"))
table(genedf$gene_name) %>% table() # checking that every gene is only represented once

#### Saving ####
# finished QC, exporting for use in Figure scripts and network construction
save(spcts, spinfo, alcts, alinfo, spaldf, genedf, file = "data_files/single_gene_models.RData")
load(file = "data_files/single_gene_models.RData")

####################### Archive ########################
#### Identifying all the genes that are totally off in one allele and on in the other ####
# higheffectgenes <- spdf %>% 
#   arrange(desc(abs(effect_size))) %>% 
#   filter(pvalue < 0.05) %>% 
#   select(gene_name) |> 
#   slice(1:500) |> 
#   pull() |> 
#   unique()
# generatePlotlist <- function(.gene_names) {
#   plotlist <- vector(mode = "list", length = 2*length(.gene_names))
#   names(plotlist) <- sapply(.gene_names, rep, 2) %>% as.character() %>% paste(c("parents", "hybrid"), sep = "_")
#   for (g in .gene_names) {
#     cat(g, which(.gene_names == g), "/", length(.gene_names), "\n")
#     g_experiments <- intersect(ExperimentNames[unlist(map(ExperimentNames, \(x) g %in% rownames(spcts[[x]])))],
#                                ExperimentNames[unlist(map(ExperimentNames, \(x) g %in% rownames(alcts[[x]])))])
#     if (length(g_experiments) == 0) { # if there are no common experiments between parents and hybrids
#       next
#     }
#     plotlist[[paste(g, "parents", sep = "_")]] <- getGeneDf(g, .mode = "parents", .experiment = g_experiments) |> 
#       visualizeGeneExpressionScatterplot(.plotname = paste(g, "parents", sep = " - "))
#     plotlist[[paste(g, "hybrid", sep = "_")]] <- getGeneDf(g, .mode = "hybrid", .experiment = g_experiments) %>%
#       visualizeGeneExpressionScatterplot(.plotname = paste(g, "hybrid", sep = " - "))
#   }
#   return(plotlist)
# }
# plotlist <- generatePlotlist(higheffectgenes)
# 
# # visualize (12 plots per figure is ideal, adjust exact number of figures as needed)
# ggarrange(plotlist = plotlist[c(1:12)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(13:24)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(25:36)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(37:48)], common.legend = TRUE) 
# ggarrange(plotlist = plotlist[c(49:60)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(61:72)], common.legend = TRUE) 
# ggarrange(plotlist = plotlist[c(73:84)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(85:96)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(97:108)], common.legend = TRUE)
# ggarrange(plotlist = plotlist[c(109:120)], common.legend = TRUE) 
# ggarrange(plotlist = plotlist[c(121:132)], common.legend = TRUE) 
# # fairly arbitrary end, just when it starts looking like the genes aren't that dramatically differentially expressed anymore
# 
# # creating manual lists of off-on genes in parents and hybrid based on above plots
# offongenes_parentsandhybrids <- c(setdiff(higheffectgenes[1:96], 
#                                           c("YCR097W", "YHR136C", "YEL073C", "YLR303W", 
#                                             "YPL209C", "YIR019C", "YGR224W", "YOL152W",
#                                             "YFL014W", "YGL256W", "YGR213C")), # first ~100 plots
#                                   "YKL218C", "YBR189W", "YOL158C", "YCL018W", "YFR055W", "YPR194C",
#                                   "YCR063W", "YIL087C", "YER046W", "YBR072W", "YDR363W", "YJL217W",
#                                   "YJL011C", "YDR448W", "YNL063W")
# offongenes_parentsonly <- c("YIL121W", "YFL014W", "YIR019C", "YGR224W", "YGL256W")
# offongenes_hybridsonly <- c("YCR097W", "YLR303W")
# 
# # presumably trans-based off-on (parents only)
# plotlist <- generatePlotlist(offongenes_parentsonly)
# ggarrange(plotlist = plotlist[c(1:(2*length(offongenes_parentsonly)))], common.legend = TRUE) 
# 
# # presumably some sort of interaction in hybrid (hybrid only)
# plotlist <- generatePlotlist(offongenes_hybridsonly)
# ggarrange(plotlist = plotlist[c(1:4)], common.legend = TRUE) 
# 
# # QC: how often are all significant effect sizes (all experimental conditions x 2 species/allele = max 10) in the same direction?
# # For each gene, check if all its sig experiments are in the same direction
# siggenes <- spaldf %>% filter(pvalue < 1e-5 & abs(effect_size) > 1) %>% select(gene_name) %>% pull() %>% unique()
# same_dir_df <- tibble(gene_name = siggenes,
#                       prop_same_dir = sapply(siggenes, \(g) {
#                         gdf <- filter(spaldf, gene_name == g & pvalue < 1e-5 & abs(effect_size) > 1)
#                         return(max(sum(sign(gdf$effect_size) == 1), sum(sign(gdf$effect_size) == -1))/nrow(gdf))
#                       }),
#                       avg_effect_magnitude = sapply(siggenes, \(g) {
#                         gdf <- filter(spaldf, gene_name == g & pvalue < 1e-5 & abs(effect_size) > 1)
#                         return(mean(abs(gdf$effect_size)))
#                       }))
# ggplot(same_dir_df, aes(x = log(avg_effect_magnitude), y = prop_same_dir)) + geom_point() 
# table(same_dir_df$prop_same_dir == 1) # vast majority are same direction
# # Or version where we don't threshold at all: check if as effect size increases, if the estimates start being more likely to be in the same direction
# GeneNames <- spaldf$gene_name %>% unique()
# same_dir_df <- tibble(gene_name = GeneNames,
#                       prop_same_dir = sapply(GeneNames, \(g) {
#                         gdf <- filter(spaldf, gene_name == g)
#                         return(max(sum(sign(gdf$effect_size) == 1), sum(sign(gdf$effect_size) == -1))/nrow(gdf))
#                       }),
#                       avg_effect_magnitude = sapply(GeneNames, \(g) {
#                         gdf <- filter(spaldf, gene_name == g)
#                         return(mean(abs(gdf$effect_size)))
#                       }))
# ggplot(same_dir_df, aes(y = log(avg_effect_magnitude), 
#                         x = round(prop_same_dir, digits = 1))) + geom_quasirandom() # as the effect size increases, the gene is more likely to have effect in the same direction in all experiments
# table(round(same_dir_df$prop_same_dir, digits = 1))

#### all experiments in one, full model ####
# archived b/c we're purposefully looking at if lfc is consistent across all experiments,
# we don't have any use for a filter for genes that have consistent lfc
# # Also running full models (all 4 experiments) to assess which conditions genes are expressed in (i.e. what divergence really matters, what's the overall divergence pattern)
# # species
# spcts_full <- Reduce(spcts, f = cbind)
# rownames(spcts_full) <- rownames(spcts[[1]])
# spinfo_full <- Reduce(spinfo, f = bind_rows)
# # allele
# alcts_full <- Reduce(alcts, f = cbind)
# rownames(alcts_full) <- rownames(alcts[[1]])
# alinfo_full <- Reduce(alinfo, f = bind_rows)
# 
# fitSingleGeneModelFull <- function(.df, .gene_name) {
#   output <- tryCatch({glm.nb(expr ~ experiment + time_point_num + genotype + allele, .df, link = log, init.theta = 7)
#   }, error = function(e) {
#     return(NA)
#   })
#   return(output)
# }
# # Tests for fitSingleGeneModelFull
# gene_idx <- sample(rownames(spcts_full), 1)
# test_df <- bind_cols(tibble(expr = spcts_full[gene_idx,]),
#                      spinfo_full)
# ggplot(test_df, aes(x = time_point_num, y = expr)) + geom_point(aes(color = allele))
# test_mod <- fitSingleGeneModelFull(test_df, gene_idx)
# summary(test_mod)$coefficients["allelecer",]
# 
# # fit models to all genes in one experiment's dataset
# fitDatasetModelsFull <- function(.cts, .info) {
#   output <- map(rownames(.cts), function(g) {
#     cat(which(rownames(.cts) == g), "/", nrow(.cts), "\n")
#     cat("currently processing", g, "\n")
#     gdf <- bind_cols(tibble(expr = .cts[g,]),
#                      .info)
#     mod <- fitSingleGeneModelFull(gdf, g)
#     return(mod)
#   })
#   return(output)
# }
# # test for fitDatasetModelsFull (don't need to let it run all the way)
# test <- fitDatasetModelsFull(spcts_full[1:10,], spinfo_full)
# sum(is.na(test)[1])
# test[[1]]
# 
# # fitting full models
# spmods_full <- fitDatasetModelsFull(spcts_full, spinfo_full)
# almods_full <- fitDatasetModelsFull(alcts_full, alinfo_full)
# names(spmods_full) <- rownames(spcts_full)
# names(almods_full) <- rownames(alcts_full)
# 
# # parsing full models
# spdf_full <- parseDfFromModslist(spmods_full)
# aldf_full <- parseDfFromModslist(almods_full)
# 
# # combining
# spdf_full$coefficient <- "species"
# aldf_full$coefficient <- "allele"
# spaldf_full <- bind_rows(spdf_full, aldf_full)
# spaldf_full$experiment <- "all"
# spaldf <- bind_rows(spaldf, spaldf_full)

#### Calling sig ####
# Archived b/c we just take effect size and pvalue and try different thresholds in other scripts
# # Calling genes that are significantly diverged in parents or hybrids in each experiment or overall
# # Purpose: Not to ID every single diverged gene, but to get a confident set we can test against a null set of randomly selected genes
# # Strategy for calling sig, 3 criteria:
# # 1) Pvalue < 0.05/(nGenes*5) (Bonferoni correction)
# # 2) Effect size > 1 (fairly arbitrary threshold)
# # 3) 75 percentile of expression > 50 (also fairly arbitrary threshold)
# 
# # pvalue threshold
# p_thresh <- 0.5/(length(unique(spaldf$gene_name))*5)
# 
# # effect size threshold
# # jitter plot of random 1000 models to see if there's a decent max effect 
# # size of non-sig genes to set as our eff_thresh (2.5 is a bit ridiculously small of a set, like 85 genes total, and there are def way more with expression differences)
# ggplot(spaldf, aes(x = (pvalue < p_thresh), y = abs(effect_size))) + geom_jitter(aes(color = pvalue < p_thresh)) + geom_hline(yintercept = 1, color = "gold")
# eff_thresh <- 1
# ggplot(spaldf, aes(x = (pvalue < p_thresh), y = abs(effect_size))) + geom_jitter(aes(color = gene_name %in% higheffectgenes)) + geom_hline(yintercept = 1, color = "gold") # note that we do know the deal with all those super high effect genes that aren't significant, they will be included in divergent set
# # visualizing that extremely high effect size group
# higheffect_lowpval_genes <- filter(spaldf, effect_size > 20) |> select(gene_name) |> pull() |> unique()
# plotlist <- generatePlotlist(higheffect_lowpval_genes)
# ggarrange(plotlist = plotlist[c(1:6)], common.legend = TRUE) 
# # YPR199C and YIR041W are in the offon list already based on other experiments 
# # (YNL321W is not for good reason)
# "YPR199C" %in% offongenes_parentsandhybrids
# "YIR041W" %in% offongenes_parentsandhybrids
# "YNL321W" %in% c(offongenes_parentsandhybrids, offongenes_parentsonly, offongenes_hybridsonly)
# 
# # 3) determining if gene is expressed
# # function to check gene is sufficiently expressed in a given experiment to test for divergence
# # for a given gene, experiment, and coefficient (allele or species), checks if the 75th percentile of gene counts in cer OR par allele is greater than a threshold (100 for now)
# checkIfExpressed <- function(.gene_name, .coefficient = c("allele", "species"), .experiment = c("all", "LowN", "CC", "HAP4", "LowPi"), .expr_thresh = 100) {
#   if (.experiment == "all") {
#     return(TRUE) # we already know that all genes in this dataset are expressed in at least one experiment
#   }
#   if (.coefficient == "allele") {
#     expr_cer <- getExprVector(.gene_name = .gene_name, .organism = "hyc", .experiment = .experiment)
#     expr_par <- getExprVector(.gene_name = .gene_name, .organism = "hyp", .experiment = .experiment)
#   }
#   if (.coefficient == "species") {
#     expr_cer <- getExprVector(.gene_name = .gene_name, .organism = "cer", .experiment = .experiment)
#     expr_par <- getExprVector(.gene_name = .gene_name, .organism = "par", .experiment = .experiment)
#   }
#   cer_expressed <- as.numeric(quantile(expr_cer, 0.75)) > .expr_thresh
#   par_expressed <- as.numeric(quantile(expr_par, 0.75)) > .expr_thresh
#   return(cer_expressed | par_expressed)
# }
# # Tests for checkIfExpressed
# # example of genes that are only truly expressed in certain experiments: YBR294W/sul1 only expressed in LowN
# # parents
# sul1 <- getGeneDf("YBR294W", .mode = "parents")
# sul1 %>% group_by(experiment) %>% summarise(mean_expr_cer = mean(cer),
#                                             mean_expr_par = mean(par))
# visualizeGeneExpressionScatterplot(sul1, .plotname = "YBR294W - parents")
# # both are fairly divergent in parents
# # hybrid
# sul1 <- getGeneDf("YBR294W", .mode = "hybrid")
# sul1 %>% group_by(experiment) %>% summarise(mean_expr_cer = mean(cer),
#                                             mean_expr_par = mean(par))
# visualizeGeneExpressionScatterplot(sul1, .plotname = "YBR294W - hybrid")
# # neither are very divergent in hybrid. Maybe SUL1 a bit
# # without having an expression level threshold, SUL1 is called as sig divergent in two experiments it's not expressed in:
# spaldf %>% filter(gene_name == "YBR294W") %>% mutate(sig = abs(effect_size) > 1 & pvalue < p_thresh)
# # YIL057C is correctly called as divergent in HAP4 in parents, but incorrectly in CC in hybrid:
# spaldf %>% filter(gene_name == "YIL057C") %>% mutate(sig = abs(effect_size) > 1 & pvalue < p_thresh)
# # With expression threshold:
# sul1df <- spaldf %>% filter(gene_name == "YBR294W")
# sul1_isExpressed <- apply(sul1df, 1, \(x) {checkIfExpressed(x["gene_name"], x["coefficient"], x["experiment"])})
# cbind(sul1_isExpressed, sul1df$experiment) # good. Just calls LowN as expressed
# sul1df$sig <- abs(sul1df$effect_size) > 1 & sul1df$pvalue < p_thresh & sul1_isExpressed
# sul1df # nothing sig, which is fair
# 
# # calling sig
# spaldf$isexpressed <- apply(spaldf, 1, \(x) {checkIfExpressed(x["gene_name"], x["coefficient"], x["experiment"])})
# spaldf$sig <- spaldf$pvalue < p_thresh & abs(spaldf$effect_size) > eff_thresh & spaldf$isexpressed
# sum(spaldf$sig)
# spaldf %>% group_by(gene_name) %>% summarise(sig_gene = any(sig)) %>% select(sig_gene) %>% pull() %>% sum()
